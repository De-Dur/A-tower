import * as THREE from 'three'
import type { TowerParameters } from '../store/useTowerStore'
import { buildFloorsData } from './tower'

type MeshBuffers = {
  positions: number[]
  normals: number[]
  colors: number[]
  indices: number[]
}

const formatFloat = (value: number) => {
  if (Math.abs(value) < 1e-8) {
    return '0'
  }
  return value.toFixed(6).replace(/\.?0+$/, '')
}

const joinFloatArray = (values: number[]) => values.map(formatFloat).join(',')

const triggerDownload = (payload: string | ArrayBuffer, filename: string, mime: string) => {
  const blob =
    typeof payload === 'string'
      ? new Blob([payload], { type: mime })
      : new Blob([payload], { type: mime })
  const url = URL.createObjectURL(blob)
  const anchor = document.createElement('a')
  anchor.href = url
  anchor.download = filename
  document.body.appendChild(anchor)
  anchor.click()
  anchor.remove()
  URL.revokeObjectURL(url)
}

const pushGeometry = (
  geometry: THREE.BufferGeometry,
  matrix: THREE.Matrix4,
  colorHex: string,
  buffers: MeshBuffers,
) => {
  const normalized = geometry.toNonIndexed()
  normalized.applyMatrix4(matrix)
  normalized.computeVertexNormals()

  const positionAttr = normalized.getAttribute('position') as THREE.BufferAttribute
  const normalAttr = normalized.getAttribute('normal') as THREE.BufferAttribute
  const vertexCount = positionAttr.count
  const color = new THREE.Color(colorHex)
  const startIndex = buffers.positions.length / 3

  for (let i = 0; i < vertexCount; i += 1) {
    buffers.positions.push(positionAttr.getX(i), positionAttr.getY(i), positionAttr.getZ(i))
    buffers.normals.push(normalAttr.getX(i), normalAttr.getY(i), normalAttr.getZ(i))
    buffers.colors.push(color.r, color.g, color.b, 1)
  }

  for (let i = 0; i < vertexCount; i += 3) {
    buffers.indices.push(startIndex + i, startIndex + i + 1, startIndex + i + 2)
  }
}

const buildTowerBuffers = (params: TowerParameters): MeshBuffers => {
  const buffers: MeshBuffers = { positions: [], normals: [], colors: [], indices: [] }
  const slices = buildFloorsData(params)
  const slabHeight = params.floorHeight * 0.9
  const slabSize = params.baseRadius * 2

  slices.forEach((slice) => {
    const matrix = new THREE.Matrix4()
    matrix.compose(
      new THREE.Vector3(0, slice.y + slabHeight / 2, 0),
      new THREE.Quaternion().setFromEuler(new THREE.Euler(0, slice.rotation, 0)),
      new THREE.Vector3(slice.scale, 1, slice.scale),
    )
    const geometry = new THREE.BoxGeometry(slabSize, slabHeight, slabSize)
    pushGeometry(geometry, matrix, slice.color, buffers)
  })

  const coreHeight = slices.length * params.floorHeight
  const coreMatrix = new THREE.Matrix4().compose(
    new THREE.Vector3(0, coreHeight / 2, 0),
    new THREE.Quaternion(),
    new THREE.Vector3(1, 1, 1),
  )
  const coreGeometry = new THREE.CylinderGeometry(
    params.baseRadius * 0.2,
    params.baseRadius * 0.2,
    coreHeight * 0.98,
    32,
    1,
    false,
  )
  pushGeometry(coreGeometry, coreMatrix, '#94a3b8', buffers)

  return buffers
}

const buildPolygonVertexIndices = (indices: number[]) => {
  const polygons: number[] = []
  for (let i = 0; i < indices.length; i += 3) {
    const a = indices[i]
    const b = indices[i + 1]
    const c = indices[i + 2]
    polygons.push(a, b, -(c + 1))
  }
  return polygons
}

const buildFbxString = (buffers: MeshBuffers) => {
  const { positions, normals, colors, indices } = buffers
  const vertexCount = positions.length / 3
  const polygonVertexIndices = buildPolygonVertexIndices(indices)
  const normalsW = new Array(vertexCount).fill(0)
  const now = new Date()
  const baseId = Number(`${now.getTime()}`.slice(-7)) * 10
  const geometryId = baseId + 1
  const modelId = baseId + 2
  const materialId = baseId + 3
  const documentId = baseId + 4

  return `; FBX 7.4.0 project file
; Generated by A-tower Generator

FBXHeaderExtension:  {
\tFBXHeaderVersion: 1003
\tFBXVersion: 7400
\tCreationTimeStamp:  {
\t\tVersion: 1000
\t\tYear: ${now.getUTCFullYear()}
\t\tMonth: ${now.getUTCMonth() + 1}
\t\tDay: ${now.getUTCDate()}
\t\tHour: ${now.getUTCHours()}
\t\tMinute: ${now.getUTCMinutes()}
\t\tSecond: ${now.getUTCSeconds()}
\t\tMillisecond: ${now.getUTCMilliseconds()}
\t}
\tCreator: "A-tower Parametric Generator"
}

GlobalSettings:  {
\tVersion: 1000
\tProperties70:  {
\t\tP: "UpAxis", "int", "Integer", "",1
\t\tP: "UpAxisSign", "int", "Integer", "",1
\t\tP: "FrontAxis", "int", "Integer", "",2
\t\tP: "FrontAxisSign", "int", "Integer", "",1
\t\tP: "CoordAxis", "int", "Integer", "",0
\t\tP: "CoordAxisSign", "int", "Integer", "",1
\t}
}

Documents:  {
\tDocument: ${documentId}, "Doc::A-tower", "" {
\t\tRootNode: 0
\t}
}

Definitions:  {
\tVersion: 100
\tCount: 3
\tObjectType: "Geometry" {
\t\tCount: 1
\t}
\tObjectType: "Material" {
\t\tCount: 1
\t}
\tObjectType: "Model" {
\t\tCount: 1
\t}
}

Objects:  {
\tGeometry: ${geometryId}, "Geometry::Tower", "Mesh" {
\t\tVertices: *${positions.length} {
\t\t\ta: ${joinFloatArray(positions)}
\t\t}
\t\tPolygonVertexIndex: *${polygonVertexIndices.length} {
\t\t\ta: ${polygonVertexIndices.join(',')}
\t\t}
\t\tGeometryVersion: 124
\t\tLayerElementNormal: 0 {
\t\t\tVersion: 102
\t\t\tName: ""
\t\t\tMappingInformationType: "ByPolygonVertex"
\t\t\tReferenceInformationType: "Direct"
\t\t\tNormals: *${normals.length} {
\t\t\t\ta: ${joinFloatArray(normals)}
\t\t\t}
\t\t\tNormalsW: *${normalsW.length} {
\t\t\t\ta: ${normalsW.join(',')}
\t\t\t}
\t\t}
\t\tLayerElementColor: 0 {
\t\t\tVersion: 101
\t\t\tName: ""
\t\t\tMappingInformationType: "ByPolygonVertex"
\t\t\tReferenceInformationType: "Direct"
\t\t\tColors: *${colors.length} {
\t\t\t\ta: ${joinFloatArray(colors)}
\t\t\t}
\t\t}
\t\tLayerElementMaterial: 0 {
\t\t\tVersion: 101
\t\t\tName: ""
\t\t\tMappingInformationType: "AllSame"
\t\t\tReferenceInformationType: "IndexToDirect"
\t\t\tMaterials: *1 {
\t\t\t\ta: 0
\t\t\t}
\t\t}
\t\tLayer: 0 {
\t\t\tVersion: 100
\t\t\tLayerElement:  {
\t\t\t\tType: "LayerElementNormal"
\t\t\t\tTypedIndex: 0
\t\t\t}
\t\t\tLayerElement:  {
\t\t\t\tType: "LayerElementColor"
\t\t\t\tTypedIndex: 0
\t\t\t}
\t\t\tLayerElement:  {
\t\t\t\tType: "LayerElementMaterial"
\t\t\t\tTypedIndex: 0
\t\t\t}
\t\t}
\t}
\tMaterial: ${materialId}, "Material::VertexColor", "" {
\t\tVersion: 102
\t\tShadingModel: "lambert"
\t\tProperties70:  {
\t\t\tP: "Diffuse", "Vector3D", "Vector", "",1,1,1
\t\t\tP: "DiffuseColor", "Color", "", "A",1,1,1
\t\t\tP: "SpecularFactor", "Number", "", "A",0
\t\t\tP: "ShininessExponent", "Number", "", "A",2
\t\t}
\t}
\tModel: ${modelId}, "Model::A-tower", "Mesh" {
\t\tVersion: 232
\t\tProperties70:  {
\t\t\tP: "InheritType", "enum", "", "",1
\t\t\tP: "Lcl Translation", "Lcl Translation", "", "A",0,0,0
\t\t\tP: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
\t\t}
\t\tShading: T
\t\tCulling: "CullingOff"
\t}
}

Connections:  {
\tC: "OO",${geometryId},${modelId}
\tC: "OO",${materialId},${modelId}
\tC: "OO",${modelId},0
}

Takes:  {
\tCurrent: "Take 001"
\tTake: "Take 001" {
\t\tFileName: ""
\t\tLocalTime: 0,0
\t\tReferenceTime: 0,0
\t}
}
`
}

const buildObjString = (buffers: MeshBuffers) => {
  const { positions, normals, colors, indices } = buffers
  const vertexCount = positions.length / 3
  const lines: string[] = []
  lines.push('# A-tower OBJ export')
  for (let i = 0; i < vertexCount; i += 1) {
    const r = colors[i * 4]
    const g = colors[i * 4 + 1]
    const b = colors[i * 4 + 2]
    lines.push(
      `v ${formatFloat(positions[i * 3])} ${formatFloat(positions[i * 3 + 1])} ${formatFloat(positions[i * 3 + 2])} ${formatFloat(r)} ${formatFloat(g)} ${formatFloat(b)}`,
    )
  }
  lines.push('')
  for (let i = 0; i < vertexCount; i += 1) {
    lines.push(
      `vn ${formatFloat(normals[i * 3])} ${formatFloat(normals[i * 3 + 1])} ${formatFloat(normals[i * 3 + 2])}`,
    )
  }
  lines.push('')
  for (let i = 0; i < indices.length; i += 3) {
    const a = indices[i] + 1
    const b = indices[i + 1] + 1
    const c = indices[i + 2] + 1
    lines.push(`f ${a}//${a} ${b}//${b} ${c}//${c}`)
  }
  return `${lines.join('\n')}\n`
}

export const exportTowerToFbx = async (params: TowerParameters) => {
  const buffers = buildTowerBuffers(params)
  const fbxString = buildFbxString(buffers)
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
  triggerDownload(fbxString, `A-tower-${timestamp}.fbx`, 'application/octet-stream')
}

export const exportTowerToObj = async (params: TowerParameters) => {
  const buffers = buildTowerBuffers(params)
  const objString = buildObjString(buffers)
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
  triggerDownload(objString, `A-tower-${timestamp}.obj`, 'text/plain')
}
